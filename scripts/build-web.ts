#!/usr/bin/env bun
import { $ } from 'bun';
import { join, relative } from 'node:path';
import { readdirSync, statSync } from 'node:fs';
import { Spinner, GREEN, DIM, BOLD, RED, CYAN, RESET } from './lib/spinner.ts';

const verbose = process.argv.includes('--verbose');

const ROOT = import.meta.dir.replace('/scripts', '');
const API_DIR = join(ROOT, 'packages/api');
const WEB_SDK_DIR = join(ROOT, 'packages/web-sdk');
const WEB_DIR = join(ROOT, 'apps/web');
const CLI_DIR = join(ROOT, 'apps/cli');
const WEB_DIST = join(WEB_DIR, 'dist');
const CLI_WEB_DIST = join(CLI_DIR, 'src/web-dist');

const startTime = performance.now();
const spinner = new Spinner();

async function run(label: string, cmd: string[], cwd: string) {
	spinner.begin(label);

	if (verbose) {
		spinner.succeed();
		const result = Bun.spawnSync(cmd, { cwd, stdout: 'inherit', stderr: 'inherit' });
		if (!result.success) {
			console.error(`\n${RED}Build failed at: ${label}${RESET}`);
			process.exit(1);
		}
		return;
	}

	const proc = Bun.spawn(cmd, { cwd, stdout: 'pipe', stderr: 'pipe' });
	const exitCode = await proc.exited;

	if (exitCode !== 0) {
		spinner.fail();
		const stderr = await new Response(proc.stderr).text();
		const stdout = await new Response(proc.stdout).text();
		console.error(`\n${RED}Build failed at: ${label}${RESET}`);
		if (stderr.trim()) console.error(stderr.trim());
		if (stdout.trim()) console.error(stdout.trim());
		process.exit(1);
	}

	spinner.succeed();
}

console.log(`\n${BOLD}${CYAN}agi${RESET} ${DIM}build${RESET}\n`);

await run('Building @agi-cli/api', ['bun', 'run', 'build'], API_DIR);
await run('Building @agi-cli/web-sdk', ['bun', 'run', 'build'], WEB_SDK_DIR);
await run('Building web UI', ['bun', 'run', 'build'], WEB_DIR);

spinner.begin('Copying web assets to CLI');
await $`rm -rf ${CLI_WEB_DIST}`.quiet();
await $`cp -r ${WEB_DIST} ${CLI_WEB_DIST}`.quiet();
spinner.succeed();

spinner.begin('Generating asset manifest');

interface Manifest {
	html: string;
	assets: {
		js: string[];
		css: string[];
		other: string[];
	};
}

function scanDirectory(dir: string, baseDir: string = dir): string[] {
	const files: string[] = [];
	const entries = readdirSync(dir);

	for (const entry of entries) {
		const fullPath = join(dir, entry);
		const stat = statSync(fullPath);

		if (stat.isDirectory()) {
			files.push(...scanDirectory(fullPath, baseDir));
		} else {
			const relativePath = relative(baseDir, fullPath);
			files.push(relativePath);
		}
	}

	return files;
}

const allFiles = scanDirectory(CLI_WEB_DIST);

const assetData = new Map<string, string>();

const manifest: Manifest = {
	html: '/index.html',
	assets: {
		js: [],
		css: [],
		other: [],
	},
};

for (const file of allFiles) {
	const urlPath = `/${file}`;
	const filePath = join(CLI_WEB_DIST, file);
	const fileBuffer = await Bun.file(filePath).arrayBuffer();
	const base64 = Buffer.from(fileBuffer).toString('base64');
	assetData.set(urlPath, base64);

	if (file.endsWith('.html')) {
	} else if (file.endsWith('.js')) {
		manifest.assets.js.push(urlPath);
	} else if (file.endsWith('.css')) {
		manifest.assets.css.push(urlPath);
	} else if (!file.endsWith('.map')) {
		manifest.assets.other.push(urlPath);
	}
}

function formatBase64Literal(base64: string): string {
	return `'${base64}'`;
}

const embeddedAssetsEntries = Array.from(assetData.entries())
	.map(([path, base64]) => `\t['${path}', ${formatBase64Literal(base64)}],`)
	.join('\n');

const manifestPath = join(CLI_WEB_DIST, 'manifest.json');
await Bun.write(manifestPath, JSON.stringify(manifest, null, 2));
spinner.succeed(`${manifest.assets.js.length} js, ${manifest.assets.css.length} css, ${manifest.assets.other.length} other`);

spinner.begin('Generating web-assets.ts');

function normalizePath(path: string): string {
	return path.replace(/^\//, '');
}

function formatAssetArray(files: string[]): string {
	if (files.length === 0) {
		return '[]';
	}

	const items = files
		.map((file) => `\t\tresolveAsset('${normalizePath(file)}')`)
		.join(',\n');

	return `[
${items}
\t]`;
}

const importsFile = `/**
 * Auto-generated file - DO NOT EDIT
 * Generated by scripts/build-web.ts
 * 
 * This file contains paths to all web UI assets.
 * The actual files are embedded via the glob pattern in package.json build script.
 */

const isCompiledBundle = (() => {
\tconst url = import.meta.url;
\treturn typeof url === 'string' && url.includes('/$bunfs/');
})();

const WEB_DIST_PREFIX = isCompiledBundle ? './src/web-dist/' : './web-dist/';

if (process.env.DEBUG_AGI_WEB_ASSETS) {
\tconsole.log('[web-assets] import.meta.url:', import.meta.url);
\tconsole.log('[web-assets] isCompiledBundle:', isCompiledBundle);
\tconsole.log('[web-assets] webDistPrefix:', WEB_DIST_PREFIX);
}

function resolveAsset(path: string) {
\tconst specifier = WEB_DIST_PREFIX + path;
\ttry {
\t\tconst resolved = import.meta.resolveSync(specifier);
\t\treturn resolved;
\t} catch {
\t\tif (process.env.DEBUG_AGI_WEB_ASSETS) {
\t\t\tconsole.warn('[web-assets] Falling back to specifier for', specifier);
\t\t}
\t\treturn specifier;
\t}
}

// Export asset paths (filesystem paths for dev + resolveAsset helper)
export const webAssetPaths = {
\thtml: resolveAsset('index.html'),
\tjs: ${formatAssetArray(manifest.assets.js)},
\tcss: ${formatAssetArray(manifest.assets.css)},
\tother: ${formatAssetArray(manifest.assets.other)},
};

// Export URL paths (for mapping requests to embedded files)
export const assetPaths = ${JSON.stringify(manifest, null, 2)};

const embeddedAssetBase64 = new Map<string, string>([
${embeddedAssetsEntries}
]);

const embeddedAssetCache = new Map<string, Uint8Array>();

export function getEmbeddedAsset(path: string): Uint8Array | undefined {
\tconst cached = embeddedAssetCache.get(path);
\tif (cached) {
\t\treturn cached;
\t}

\tconst base64 = embeddedAssetBase64.get(path);
\tif (!base64) {
\t\treturn undefined;
\t}

\tconst buffer = Buffer.from(base64, 'base64');
\tembeddedAssetCache.set(path, buffer);
\treturn buffer;
}
`;

const importsFilePath = join(CLI_DIR, 'src/web-assets.ts');
await Bun.write(importsFilePath, importsFile);
spinner.succeed();

const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
console.log(`\n${GREEN}${BOLD}  âœ“${RESET} Web build complete ${DIM}in ${elapsed}s${RESET}\n`);
