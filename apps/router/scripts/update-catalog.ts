/**
 * Fetch models catalog from models.dev and generate src/catalog/index.ts
 * Usage: bun run scripts/update-catalog.ts
 */

const SOURCE = 'https://models.dev/api.json';
const TARGET = 'src/catalog/index.ts';

type ProviderId = 'openai' | 'anthropic';

const isAllowedOpenAIModel = (id: string): boolean => {
  if (id === 'codex-mini-latest') return true;
  if (id.startsWith('gpt-5')) return true;
  if (id.includes('codex')) return true;
  return false;
};

const isAllowedAnthropicModel = (id: string): boolean => {
  if (id.includes('-3-5-')) return true;
  if (id.includes('-4-') || id.includes('-4.')) return true;
  if (id.match(/claude-(haiku|sonnet|opus)-4/)) return true;
  return false;
};

interface ModelCost {
  input?: number;
  output?: number;
  cacheRead?: number;
  cacheWrite?: number;
}

interface ModelLimit {
  context?: number;
  output?: number;
}

interface ModelInfo {
  id: string;
  label?: string;
  cost?: ModelCost;
  limit?: ModelLimit;
  toolCall?: boolean;
  reasoning?: boolean;
}

interface ProviderEntry {
  id: ProviderId;
  models: ModelInfo[];
}

interface FeedModel {
  id?: string;
  name?: string;
  cost?: {
    input?: number;
    output?: number;
    cache_read?: number;
    cache_write?: number;
  };
  limit?: {
    context?: number;
    output?: number;
  };
  tool_call?: boolean;
  reasoning?: boolean;
}

interface FeedProvider {
  id: string;
  name?: string;
  models: Record<string, FeedModel>;
}

type Feed = Record<string, FeedProvider>;

const SUPPORTED_PROVIDERS: ProviderId[] = ['openai', 'anthropic'];

function mapModel(id: string, raw?: FeedModel): ModelInfo {
  const m = raw ?? {};
  const info: ModelInfo = { id: String(m.id ?? id) };

  if (typeof m.name === 'string' && m.name.trim()) {
    info.label = m.name.trim();
  }

  if (m.cost) {
    const cost: ModelCost = {};
    if (typeof m.cost.input === 'number') cost.input = m.cost.input;
    if (typeof m.cost.output === 'number') cost.output = m.cost.output;
    if (typeof m.cost.cache_read === 'number') cost.cacheRead = m.cost.cache_read;
    if (typeof m.cost.cache_write === 'number') cost.cacheWrite = m.cost.cache_write;
    if (Object.keys(cost).length > 0) info.cost = cost;
  }

  if (m.limit) {
    const limit: ModelLimit = {};
    if (typeof m.limit.context === 'number') limit.context = m.limit.context;
    if (typeof m.limit.output === 'number') limit.output = m.limit.output;
    if (Object.keys(limit).length > 0) info.limit = limit;
  }

  if (typeof m.tool_call === 'boolean') info.toolCall = m.tool_call;
  if (typeof m.reasoning === 'boolean') info.reasoning = m.reasoning;

  return info;
}

function pickProviders(feed: Feed): Record<ProviderId, ProviderEntry> {
  const out = {} as Record<ProviderId, ProviderEntry>;

  for (const providerId of SUPPORTED_PROVIDERS) {
    out[providerId] = { id: providerId, models: [] };
  }

  for (const [key, entry] of Object.entries(feed)) {
    if (!SUPPORTED_PROVIDERS.includes(key as ProviderId)) continue;

    const providerId = key as ProviderId;
    const models: ModelInfo[] = [];

    for (const [modelId, modelData] of Object.entries(entry.models || {})) {
      if (providerId === 'openai' && !isAllowedOpenAIModel(modelId)) {
        continue;
      }
      if (providerId === 'anthropic' && !isAllowedAnthropicModel(modelId)) {
        continue;
      }
      models.push(mapModel(modelId, modelData));
    }

    models.sort((a, b) => a.id.localeCompare(b.id));
    out[providerId] = { id: providerId, models };
  }

  return out;
}

function generateTs(catalog: Record<ProviderId, ProviderEntry>): string {
  const header = `// AUTO-GENERATED by scripts/update-catalog.ts - Do not edit manually
// Last updated: ${new Date().toISOString()}
`;

  const types = `
export type ProviderId = 'openai' | 'anthropic';

export interface ModelCost {
  input?: number;
  output?: number;
  cacheRead?: number;
  cacheWrite?: number;
}

export interface ModelLimit {
  context?: number;
  output?: number;
}

export interface ModelInfo {
  id: string;
  label?: string;
  cost?: ModelCost;
  limit?: ModelLimit;
  toolCall?: boolean;
  reasoning?: boolean;
}

export interface ProviderEntry {
  id: ProviderId;
  models: ModelInfo[];
}
`;

  const body = `export const catalog: Record<ProviderId, ProviderEntry> = ${JSON.stringify(catalog, null, 2)};`;

  return `${header}${types}\n${body}\n`;
}

async function main() {
  console.log(`Fetching ${SOURCE}...`);
  
  const res = await fetch(SOURCE);
  if (!res.ok) {
    throw new Error(`Failed to fetch: ${res.status} ${res.statusText}`);
  }

  const feed = (await res.json()) as Feed;
  const catalog = pickProviders(feed);

  const openaiCount = catalog.openai.models.length;
  const anthropicCount = catalog.anthropic.models.length;

  console.log(`Found ${openaiCount} OpenAI models, ${anthropicCount} Anthropic models`);

  const ts = generateTs(catalog);
  await Bun.write(TARGET, ts);

  console.log(`Wrote ${TARGET}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
