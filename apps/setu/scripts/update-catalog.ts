/**
 * Fetch models catalog from models.dev and generate src/catalog/index.ts
 * Usage: bun run scripts/update-catalog.ts
 */

const SOURCE = 'https://models.dev/api.json';
const TARGET = 'src/catalog/index.ts';

type ProviderId = 'openai' | 'anthropic' | 'moonshot';

const FEED_TO_PROVIDER: Record<string, ProviderId> = {
	openai: 'openai',
	anthropic: 'anthropic',
	'moonshotai-cn': 'moonshot',
};

const isAllowedOpenAIModel = (id: string): boolean => {
	if (id === 'codex-mini-latest') return true;
	if (id.startsWith('gpt-5')) return true;
	if (id.includes('codex')) return true;
	return false;
};

const isAllowedAnthropicModel = (id: string): boolean => {
	if (id.includes('-3-5-')) return true;
	if (id.includes('-4-') || id.includes('-4.')) return true;
	if (id.match(/claude-(haiku|sonnet|opus)-4/)) return true;
	return false;
};

const isAllowedMoonshotModel = (id: string): boolean => {
	if (id.startsWith('kimi-k2')) return true;
	return false;
};

interface ModelCost {
	input?: number;
	output?: number;
	cacheRead?: number;
	cacheWrite?: number;
}

interface ModelLimit {
	context?: number;
	output?: number;
}

interface ModelInfo {
	id: string;
	label?: string;
	cost?: ModelCost;
	limit?: ModelLimit;
	toolCall?: boolean;
	reasoning?: boolean;
}

interface ProviderEntry {
	id: ProviderId;
	models: ModelInfo[];
}

interface FeedModel {
	id?: string;
	name?: string;
	cost?: {
		input?: number;
		output?: number;
		cache_read?: number;
		cache_write?: number;
	};
	limit?: {
		context?: number;
		output?: number;
	};
	tool_call?: boolean;
	reasoning?: boolean;
}

interface FeedProvider {
	id: string;
	name?: string;
	models: Record<string, FeedModel>;
}

type Feed = Record<string, FeedProvider>;

const SUPPORTED_PROVIDERS: ProviderId[] = ['openai', 'anthropic', 'moonshot'];

function mapModel(id: string, raw?: FeedModel): ModelInfo {
	const m = raw ?? {};
	const info: ModelInfo = { id: String(m.id ?? id) };

	if (typeof m.name === 'string' && m.name.trim()) {
		info.label = m.name.trim();
	}

	if (m.cost) {
		const cost: ModelCost = {};
		if (typeof m.cost.input === 'number') cost.input = m.cost.input;
		if (typeof m.cost.output === 'number') cost.output = m.cost.output;
		if (typeof m.cost.cache_read === 'number')
			cost.cacheRead = m.cost.cache_read;
		if (typeof m.cost.cache_write === 'number')
			cost.cacheWrite = m.cost.cache_write;
		if (Object.keys(cost).length > 0) info.cost = cost;
	}

	if (m.limit) {
		const limit: ModelLimit = {};
		if (typeof m.limit.context === 'number') limit.context = m.limit.context;
		if (typeof m.limit.output === 'number') limit.output = m.limit.output;
		if (Object.keys(limit).length > 0) info.limit = limit;
	}

	if (typeof m.tool_call === 'boolean') info.toolCall = m.tool_call;
	if (typeof m.reasoning === 'boolean') info.reasoning = m.reasoning;

	return info;
}

function pickProviders(feed: Feed): Record<ProviderId, ProviderEntry> {
	const out = {} as Record<ProviderId, ProviderEntry>;

	for (const providerId of SUPPORTED_PROVIDERS) {
		out[providerId] = { id: providerId, models: [] };
	}

	for (const [key, entry] of Object.entries(feed)) {
		const providerId = FEED_TO_PROVIDER[key];
		if (!providerId) continue;

		const models: ModelInfo[] = [];

		for (const [modelId, modelData] of Object.entries(entry.models || {})) {
			if (providerId === 'openai' && !isAllowedOpenAIModel(modelId)) {
				continue;
			}
			if (providerId === 'anthropic' && !isAllowedAnthropicModel(modelId)) {
				continue;
			}
			if (providerId === 'moonshot' && !isAllowedMoonshotModel(modelId)) {
				continue;
			}
			models.push(mapModel(modelId, modelData));
		}

		models.sort((a, b) => a.id.localeCompare(b.id));
		out[providerId] = { id: providerId, models };
	}

	return out;
}

/**
 * Pricing overrides for models not yet updated in models.dev feed.
 * Remove entries once the upstream feed is updated.
 */
const PRICING_OVERRIDES: Record<string, Partial<ModelInfo>> = {
	// Kimi K2.5 pricing from https://platform.moonshot.ai/docs/pricing/chat#generation-model-kimi-k2
	// Input (Cache Miss): $0.60 per 1M, Input (Cache Hit): $0.10 per 1M, Output: $3.00 per 1M
	'kimi-k2.5': {
		cost: {
			input: 0.6,
			output: 3.0,
			cacheRead: 0.1,
			cacheWrite: 0.6,
		},
	},
};

/**
 * Apply pricing overrides to the catalog.
 */
function applyPricingOverrides(
	catalog: Record<ProviderId, ProviderEntry>,
): void {
	for (const entry of Object.values(catalog)) {
		for (const model of entry.models) {
			const override = PRICING_OVERRIDES[model.id];
			if (override) {
				if (override.cost) {
					model.cost = { ...model.cost, ...override.cost };
				}
			}
		}
	}
}

function generateTs(catalog: Record<ProviderId, ProviderEntry>): string {
	const header = `// AUTO-GENERATED by scripts/update-catalog.ts - Do not edit manually
// Last updated: ${new Date().toISOString()}
`;

	const types = `
export type ProviderId = 'openai' | 'anthropic' | 'moonshot';

export interface ModelCost {
  input?: number;
  output?: number;
  cacheRead?: number;
  cacheWrite?: number;
}

export interface ModelLimit {
  context?: number;
  output?: number;
}

export interface ModelInfo {
  id: string;
  label?: string;
  cost?: ModelCost;
  limit?: ModelLimit;
  toolCall?: boolean;
  reasoning?: boolean;
}

export interface ProviderEntry {
  id: ProviderId;
  models: ModelInfo[];
}
`;

	const body = `export const catalog: Record<ProviderId, ProviderEntry> = ${JSON.stringify(catalog, null, 2)};`;

	return `${header}${types}\n${body}\n`;
}

async function main() {
	console.log(`Fetching ${SOURCE}...`);

	const res = await fetch(SOURCE);
	if (!res.ok) {
		throw new Error(`Failed to fetch: ${res.status} ${res.statusText}`);
	}

	const feed = (await res.json()) as Feed;
	const catalog = pickProviders(feed);

	applyPricingOverrides(catalog);

	const openaiCount = catalog.openai.models.length;
	const anthropicCount = catalog.anthropic.models.length;
	const moonshotCount = catalog.moonshot.models.length;

	console.log(
		`Found ${openaiCount} OpenAI models, ${anthropicCount} Anthropic models, ${moonshotCount} Moonshot models`,
	);

	const ts = generateTs(catalog);
	await Bun.write(TARGET, ts);

	console.log(`Wrote ${TARGET}`);
}

main().catch((err) => {
	console.error(err);
	process.exit(1);
});
